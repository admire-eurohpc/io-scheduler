/******************************************************************************
 * Copyright 2021, Barcelona Supercomputing Center (BSC), Spain
 *
 * This software was partially supported by the EuroHPC-funded project ADMIRE
 *   (Project ID: 956748, https://www.admire-eurohpc.eu).
 *
 * This file is part of scord.
 *
 * scord is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * scord is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with scord.  If not, see <https://www.gnu.org/licenses/>.
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *****************************************************************************/

/*
 * This file contains the code to implement an options map that can
 * be generated by parsing a configuration according to the structure
 * defined by a file_schema instance.
 */

#ifndef SCORD_CONFIG_FILE_OPTIONS_DESCRIPTION_HPP
#define SCORD_CONFIG_FILE_OPTIONS_DESCRIPTION_HPP

#include <yaml-cpp/yaml.h>
#include <boost/any.hpp>
#include <utility>

namespace file_options {

/*! Class to handle values of an arbitrary type */
struct option_value {
    /*! Constructor. The 'value' parameter is  passed (and stored)
     * as boost::any in order to handle arbitrarily-typed values */
    explicit option_value(boost::any value) : m_value(std::move(value)) {}

    /*! If the stored value is of type T, returns that value.
     * Otherwise throws boost::bad_any_cast exception */
    template <typename T>
    T&
    get_as() {
        return boost::any_cast<T&>(m_value);
    }

    /*! If the stored value is of type T, returns that value.
     * Otherwise throws boost::bad_any_cast exception */
    template <typename T>
    const T&
    get_as() const {
        return boost::any_cast<const T&>(m_value);
    }

    /*! Stored option value */
    boost::any m_value;
};

/*! Class to handle a group of related options. The stored options
 * can be accessed using the usual std::map interface. */
struct options_group : public std::map<std::string, option_value> {

    bool
    has(const std::string& opt_name) const {
        return count(opt_name) != 0;
    }

    /*! If the options_group contains an option named 'opt_name'
     * of type T, returns the value for that option.
     * If the option does not exist, throws std::invalid_argument exception.
     * Otherwise throws boost::bad_any_cast exception */
    template <typename T>
    const T&
    get_as(const std::string& opt_name) const {

        auto it = find(opt_name);

        if(it == end()) {
            throw std::invalid_argument("option '" + opt_name + "' missing");
        }

        return it->second.get_as<T>();
    }
};

/*! Class to handle a list of several groups */
using options_list = std::vector<options_group>;

/*! Class that stores the values for the defined variables so that they
 * can be accessed in a key-value manner.
 * This class is derived from std::map<std::string, boost::any>,
 * therefore all usual std::map operators can be used to access
 * its contents */
struct options_map : public std::map<std::string, boost::any> {

    /*! If the options_map contains an option named 'opt_name'
     * of type T, returns the value for that option.
     * If the option does not exist, throws std::invalid_argument exception.
     * Otherwise throws boost::bad_any_cast exception */
    template <typename T>
    T&
    get_as(const std::string& opt_name) {

        auto it = find(opt_name);

        if(it == end()) {
            throw std::invalid_argument("option '" + opt_name + "' missing");
        }

        return boost::any_cast<T&>(it->second);
    }
};

} // namespace file_options

#endif /* SCORD_CONFIG_FILE_OPTIONS_DESCRIPTION_HPP */
